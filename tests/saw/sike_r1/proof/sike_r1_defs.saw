//base.saw Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0


///////////////////////////////////////////////////////////////////////////////
// SIKE definitions and helper functions used by all proofs


///////////////////////////////////////////////////////////////////////////////
// SIKE constants and types

let RADIX = 64;
let NBITS_FIELD = 503;
let NBITS_ORDER = 256;
let MAXBITS_ORDER = NBITS_ORDER;
let max_words_order = eval_int {{ `((MAXBITS_ORDER + RADIX - 1) / RADIX) : [64] }};
let nwords_field = 8;
let half_nwords_field = 4;
let twice_nwords_field = 16;
let nwords_point = 32;

let OALICE_BITS = 250;
let OBOB_BITS  = 253;

let MSG_BYTES = 24;
let SECRETKEY_A_BYTES = eval_int {{ `((OALICE_BITS + 7) / 8) : [64] }};
let SECRETKEY_B_BYTES = eval_int {{ `((OBOB_BITS + 7) / 8) : [64] }};
let FP2_ENCODED_BYTES = eval_int {{ `(2 * ((NBITS_FIELD + 7) / 8)) : [64] }};

let CRYPTO_PUBLICKEYBYTES = eval_int {{ `(3 * FP2_ENCODED_BYTES) : [64] }};
let CRYPTO_SECRETKEYBYTES = eval_int {{ `(MSG_BYTES + SECRETKEY_B_BYTES + CRYPTO_PUBLICKEYBYTES) : [64] }};
let CRYPTO_CIPHERTEXTBYTES = eval_int {{ `(CRYPTO_PUBLICKEYBYTES + MSG_BYTES) : [64] }};
let CRYPTO_BYTES = 16;

let SHAKE128_RATE = 168;
let SHAKE256_RATE = 136;

let CIPHERTEXT_PLUS_MSG_BYTES = eval_int {{ `(CRYPTO_CIPHERTEXTBYTES + MSG_BYTES) : [64] }};


///////////////////////////////////////////////////////////////////////////////
// Function names

let clear_words_fun_name = "clear_words_r1";
let copy_words_fun_name = "copy_words_r1";
let digit_x_digit_fun_name = "digit_x_digit_r1";
let is_digit_lessthan_ct_fun_name = "is_digit_lessthan_ct";
let is_digit_nonzero_ct_fun_name = "is_digit_nonzero_ct";
let is_digit_zero_ct_fun_name = "is_digit_zero_ct";
let mp_add_fun_name = "mp_add_r1";
let mp_addfast_fun_name = "mp_addfast_r1";
let mp_addfastx2_fun_name = "mp_addfastx2_r1";
let mp_sub_fun_name = "mp_sub_r1";
let mp_subfast_fun_name = "mp_subfast_r1";
let mp_mul_fun_name = "mp_mul_r1";
let mp_shiftr1_fun_name = "mp_shiftr1_r1";

let fpzero_fun_name = "fpzero503";
let fpcopy_fun_name = "fpcopy503";
let fpcorrection_fun_name = "fpcorrection503";
let fpneg_fun_name = "fpneg503";
let fpadd_fun_name = "fpadd503";
let fpsub_fun_name = "fpsub503";
let fpdiv2_fun_name = "fpdiv2_503";
let rdc_mont_fun_name = "rdc_mont_r1";
let fpmul_mont_fun_name = "fpmul503_mont";
let fpsqr_mont_fun_name = "fpsqr503_mont";
let fpinv_chain_mont_fun_name = "fpinv503_chain_mont";
let fpinv_mont_fun_name = "fpinv503_mont";
let to_mont_fun_name = "to_mont_r1";
let from_mont_fun_name = "from_mont_r1";
let fp2copy_fun_name = "fp2copy503";
let fp2correction_fun_name = "fp2correction503";
let fp2neg_fun_name = "fp2neg503";
let fp2add_fun_name = "fp2add503";
let fp2sub_fun_name = "fp2sub503";
let fp2div2_fun_name = "fp2div2_503";
let fp2mul_mont_fun_name = "fp2mul503_mont";
let fp2sqr_mont_fun_name = "fp2sqr503_mont";
let fp2inv_mont_fun_name = "fp2inv503_mont";
let to_fp2mont_fun_name = "to_fp2mont_r1";
let from_fp2mont_fun_name = "from_fp2mont_r1";

let xDBL_fun_name = "xDBL_r1";
let xDBLe_fun_name = "xDBLe_r1";
let xTPL_fun_name = "xTPL_r1";
let xTPLe_fun_name = "xTPLe_r1";

let get_3_isog_fun_name = "get_3_isog_r1";
let get_4_isog_fun_name = "get_4_isog_r1";
let eval_3_isog_fun_name = "eval_3_isog_r1";
let eval_4_isog_fun_name = "eval_4_isog_r1";
let get_A_fun_name = "get_A_r1";
let inv_3_way_fun_name = "inv_3_way_r1";
let j_inv_fun_name = "j_inv_r1";
let xDBLADD_fun_name = "xDBLADD_r1";
let swap_points_fun_name = "swap_points_r1";
let LADDER3PT_fun_name = "LADDER3PT_r1";

let random_mod_order_B_fun_name = "random_mod_order_B_r1";
let init_basis_fun_name = "init_basis_r1";
let fp2_decode_fun_name = "fp2_decode_r1";
let fp2_encode_fun_name = "fp2_encode_r1";
let EphemeralKeyGeneration_A_fun_name = "EphemeralKeyGeneration_A_r1";
let EphemeralKeyGeneration_B_fun_name = "EphemeralKeyGeneration_B_r1";
let EphemeralSecretAgreement_A_fun_name = "EphemeralSecretAgreement_A_r1";
let EphemeralSecretAgreement_B_fun_name = "EphemeralSecretAgreement_B_r1";

let load64_fun_name = "load64_r1";
let store64_fun_name = "store64_r1";
let KeccakF1600_StatePermute_fun_name = "KeccakF1600_StatePermute_r1";
let keccak_absorb_fun_name = "keccak_absorb_r1";
let keccak_squeezeblocks_fun_name = "keccak_squeezeblocks_r1";
let cshake256_simple_absorb_fun_name = "cshake256_simple_absorb_r1";
let cshake256_simple_fun_name = "cshake256_simple_r1";

let SIKE_crypto_kem_keypair_fun_name = "SIKE_P503_r1_crypto_kem_keypair";
let SIKE_crypto_kem_enc_fun_name = "SIKE_P503_r1_crypto_kem_enc";
let SIKE_crypto_kem_dec_fun_name = "SIKE_P503_r1_crypto_kem_dec";


let char_t = llvm_int 8;
// NOTE: This value would be 32 on a 32-bit architecture
let digit_t = llvm_int 64;

let felm_t = llvm_array nwords_field digit_t;
let dfelm_t = llvm_array twice_nwords_field digit_t;
let f2elm_t = llvm_array 2 felm_t;


///////////////////////////////////////////////////////////////////////////////
// Aliases

let point_struct = llvm_struct "struct.point_proj";
let point_proj_t = llvm_array 1 point_struct;
let fresh_digit n = crucible_fresh_var n digit_t;

// NOTE: These values are read but never modified
let A_param v ty= ptr_to_fresh_readonly v ty;
let A_felm_t v = ptr_to_fresh_readonly v felm_t;
let A_f2elm_t v = ptr_to_fresh_readonly v f2elm_t;
let A_dfelm_t v = ptr_to_fresh_readonly v dfelm_t;
let A_point_t v = ptr_to_fresh_readonly v point_proj_t;
let A_digit_t v = ptr_to_fresh_readonly v digit_t;
let A_int_t v = crucible_fresh_var v i32;
let A_uint_t v = crucible_fresh_var v i32;
let A_uint64_t v = crucible_fresh_var v (llvm_int 64);
let A_char_t v = ptr_to_fresh_readonly v char_t;
let A_digit_it v = crucible_fresh_var v digit_t;

// NOTE: This values are read and potentially modified
let B_felm_t v = ptr_to_fresh v felm_t;
let B_f2elm_t v = ptr_to_fresh v f2elm_t;
let B_point_t v = ptr_to_fresh v point_proj_t;

// NOTE: This values are outputs
let C_felm_t() = crucible_alloc felm_t;
let C_f2elm_t() = crucible_alloc f2elm_t;
let C_point_t() = crucible_alloc point_proj_t;

// NOTE: we are overiding memcmp as it is not link in the bc file
let memcmp_simple_spec nbytes = do {
    (x, xp) <- ptr_to_fresh_readonly "x" (llvm_array nbytes i8);
    (y, yp) <- ptr_to_fresh_readonly "y" (llvm_array nbytes i8);
    n <- crucible_fresh_var "n" (llvm_int 64);
    crucible_precond {{ n == `nbytes }};
    crucible_execute_func [xp, yp, (tm n)];
    crucible_return 
        (tm {{ if x < y then -1 else if x == y then 0:[32] else 1 }});
};

memcmp_ov_for_kem_dec <- admit "memcmp" [] (memcmp_simple_spec 378);


/* Note the following conventions: 
"_ov" indicates an overrides, "O" is a list of overrides, "U" is a list of uninterpreted functions.
Overrides is a proof specification that can be used as input to other proofs.
Uninterpreted functions are cryptol function that will not get unwrapped/unrolled by the solver.
*/
