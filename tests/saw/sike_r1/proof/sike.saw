//sike.saw Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

///////////////////////////////////////////////////////////////////////////////
// Verify the top-level SIKE functions

import "../spec/Loader.cry";
import "../spec/interface/sidh.cry";
import "../spec/shared/Constants.cry";
import "../spec/interface/cshake.cry";
import "../spec/interface/sike.cry";

///////////////////////////////////////////////////////////////////////////////
// Specifications

// NOTE: These functions contain extra precoditions that are inherited from
//       the called functions in SIDH. The true facts can be removed.

let add_bogus_preconditions = do {
    crucible_precond {{ pftwice_mod g_Montgomery_one }};
    crucible_precond {{ pftwice_mod zero }};
    crucible_precond {{ fpnorm zero == zero }};
    crucible_precond {{ fpnorm g_Montgomery_one == g_Montgomery_one }};
    crucible_precond {{ is_good_basis A_gen }};
    crucible_precond {{ is_good_basis B_gen }};
};

let crypto_kem_enc_spec = do {
    ctp <- crucible_alloc (llvm_array CRYPTO_CIPHERTEXTBYTES char_t);
    ssp <- crucible_alloc (llvm_array CRYPTO_BYTES char_t);
    (pk, pkp) <- ptr_to_fresh_readonly "pk" (llvm_array CRYPTO_PUBLICKEYBYTES char_t);
    add_bogus_preconditions;
    crucible_precond {{ is_good_pk_encoding pk }};
    crucible_execute_func [ctp, ssp, pkp];
    _ <- points_to_fresh ctp "ct" (llvm_array CRYPTO_CIPHERTEXTBYTES char_t);
    _ <- points_to_fresh ssp "ss" (llvm_array CRYPTO_BYTES char_t);
    crucible_return (crucible_term {{ 0:[32] }});
};

let crypto_kem_dec_spec = do {
    ssp <- crucible_alloc (llvm_array CRYPTO_BYTES char_t);
    (ct, ctp) <- ptr_to_fresh_readonly "ct" (llvm_array CRYPTO_CIPHERTEXTBYTES char_t);
    (sk, skp) <- ptr_to_fresh_readonly "sk" (llvm_array CRYPTO_SECRETKEYBYTES char_t);
    add_bogus_preconditions;
    crucible_precond {{ is_good_pk_encoding (take ct) }};
    crucible_execute_func [ssp, ctp, skp];
    _ <- points_to_fresh ssp "ss" (llvm_array CRYPTO_BYTES char_t);
    crucible_return (crucible_term {{ 0:[32] }});
};

let crypto_kem_keypair_spec = do {
    pkp <- crucible_alloc (llvm_array CRYPTO_PUBLICKEYBYTES char_t);
    skp <- crucible_alloc (llvm_array CRYPTO_SECRETKEYBYTES char_t);
    add_bogus_preconditions;
    crucible_execute_func [pkp, skp];
    _ <- points_to_fresh pkp "pk" (llvm_array CRYPTO_PUBLICKEYBYTES char_t);
    _ <- points_to_fresh skp "sk" (llvm_array CRYPTO_SECRETKEYBYTES char_t);
    crucible_return (crucible_term {{ 0:[32] }});
};

///////////////////////////////////////////////////////////////////////////////
// Proof commands

crypto_kem_keypair_ov <- verify "SIKE_P503_r1_crypto_kem_keypair"
    [ randombytes_sike_ov
    , random_mod_order_B_unint_ov
    , ephemeralKeyGeneration_B_ov
    ]
    crypto_kem_keypair_spec;

crypto_kem_enc_ov <- verify_unint "SIKE_P503_r1_crypto_kem_enc"
    [ randombytes_sike_ov
    , ephemeralSecretAgreement_A_ov
    , ephemeralKeyGeneration_A_ov
    , cshake256_simple_enc_ov0
    , cshake256_simple_enc_ov1
    , cshake256_simple_enc_ov2
    ]
    [ "cshake"
    , "pftwice_mod"
    , "fpnorm"
    , "is_good_pk_encoding"
    , "is_good_basis"
    ];
    crypto_kem_enc_spec;

crypto_kem_dec_ov <- verify_unint "SIKE_P503_r1_crypto_kem_dec"
    [ ephemeralSecretAgreement_B_ov
    , cshake256_simple_enc_ov0
    , cshake256_simple_enc_ov1
    , cshake256_simple_enc_ov2
    , ephemeralKeyGeneration_A_ov
    , memcmp_ov_for_kem_dec
    ]
    [ "cshake"
    , "pf2twice_mod"
    , "pftwice_mod"
    , "fp2norm"
    , "fpnorm"
    , "is_good_fp2_encoding"
    , "is_good_basis"
    ]
    crypto_kem_dec_spec;

